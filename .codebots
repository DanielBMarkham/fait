Hey, I'd like you to generate some code for me. I outlined what I'd like.

### Structure
I would like five files in total.
- A text file full of common English nouns, verbs, adverbs, and ajectives. These words should be randomly generated and put into clusters separated by tabs. There should be a 100 lines of this text file. I will call this sample.txt. Each line may contain no clusters in columns or it may contain up to a dozen such clusters. Each cluster can be up to seven randomly chosen words. Empty columns can appear can appear in any location
- The next two files will be companion files and architected and coded as much of the same way as possible. They will be F# script files runnable from either bash or dos. They will be named app.fsx and app-test.fsx
- The final two files will be OS commands that wrap these files for each of the OSes. These will have the same name as their corresponding F# script files. For instance, there will be an app.cmd that calls the app.fsx from the dos command line. Likewise there should be an app file with bash shell instructions to call the bash version of these. The goal is to just use one simple word for running these apps from the command line. This should help future programmers use the code without having to know all of the details underneath.
- These files will contain no linkages or dependencies on anything but the underlying dotnet sdk code or OS framework. There are no custom libraries, database drivers, or helper files. As much as possible, there should never be an issue with some vendor code being patched or updated and it breaking these two F# script files. Because of the way we're wrapping these two scripts, the same text should result in the same result regardless of which OS the user is using.
- As much as possible, all F# code should be written as pure functions
- Since both the app and test use a jagged string array with holes, at the heart of both the app script and the app-test script should be a function. It takes a string array, does something with it, I don't care, reverses everything maybe, and returns the same type. This means that in addition to app and app-test being mirror programs, each able to recieve the output of the other, these two functions are same. This means that future users of the code can use the functionality by simply bypassing all the IO and calling these functions directly
- The test app will not necessarily use its input data as tests, at least not now. Instead, you'll add six "smoke tests" that will be used later to verify basic operation. You can code in whatever you'd like here. Maybe a bit of passing and failing. When the test gets a result, it puts it in a WARN log message, in addition to logging entrance and exit if the INFO option has been selected

### Operation
In operation, these two script files should perform just like the cat utility built into bash, except they use the data instead of just typing it out like cat does. This means several things
- Because they work like cat, the programs should error error out. They always do something, even if it's just waiting on input. They provide the user with unexpected results, but there never should be a programming problem that tosses an exception back at the user. It just works.
- Since they both generate and consume tab delimited text, each one should be able to pipe into the other one. In other words, in bash cat sample.txt | app | app-test should work without error as well as the reverse, cat sample.txt | app-test | app
- These programs should operate in stream mode, not loading everything in at once. This will allow other programs to open a pipe to these apps and write intermittantly over time without have to restart the app. When they close the stream, then the program closes
- If a file is provided by stream, such as the example above, app and app-test processes that stream and then releases all resources
- All input and output to these scripts should use the OS standard, eg stdin, stout, and sterr
- Each of these two scripts should support a default set of command line parameters that one would expect from the underlying OS. -i for input file, -o for output file, -v to set verbosity level, and -h for help
- If the help option is provided, the appropriate help information is sent out first, before any processing takes place. This allows new users to make mistakes and then correct them, such as having a hanging terming (where neither an input file or piped input is provided, they're left to provide text by typing it in at the console, which isn't always clear to them.) The help text should explain all of the options and provide several usage examples in both dos and bash.
- verbosity has three levels, INFO, WARN, and ERROR. ERROR is the default. When requesting the INFO mode, all function entrances and exits are logged

### Testing
In adition to all of this, if you can provide any of this also as an executable test called from the command line, that would be great. Should be one version for bash and one for dos

// You made a try-with-finally when you can't do that. It has to be a try-finally wrapping another try-with. Here, I fixed it for you 
(think code checkin)
// I need you to make the command line options double dash instead of single dash, ie --h instead of -h. Otherwise the options keep escaping the script and end up being processed by dotnet. Be sure to fix both files
(think think code checkin)
// Smoke tests run. Can you add in a --dt option that puts a high precision UTC datetime at the beginning of any log message?
(think think think code checkin)
// Looks good. I think this is the final big architectural request for a while. Both of these scripts have a pure functional heart, it's processData. I'd like to lift both of these processDatas out of the scripts and put into one library, let's call it applib. Since they have the same name, we'll need to rename them processAppData for the app.fsx script and processAppTestData for the app-test script. Each also has dependencies that need to be lifted out and renamed appropriately. This will allow both the app and app-test scripts to use the same library and also for the heart of the code to be reused by other applications
(think think code checkin)
// Hey grok, I think you screwed that up. The compiler doesn't understand what verbosity means in the app.fsx like on line 23. That looks like a scoping issue. In fact, since we want both of these scripts to have the same exterior interface, let's move all of that common code, the options, logging, and whatnot to another file. Let's call it applib
(think think think code checkin)
// Can you fix applib.fsx? It doesn't seem to know what fsi is, or parseArgs. I think it's missing some dependencies
(think think code checkin)
// Now I've got that same fsi problem over in app and app-test, starting with line 34. Neither one of them also seem to know what the parseArgs function is, which should be in the included applib.fsx file. Also neither app.fsx or app-test.fsx seem to know what a StreamReader is, which is really strange. Can you fix that?
// When I run  cat sample.txt | ./app from bash I get app.fsx(40,43): error FS0039: The value or constructor 'parseArgs' is not defined.
(think think code checkin)
// Now when I run it I get app.fsx(5,44): error FS0039: The namespace 'Shell' is not defined.
(think think code checkin)
// Now it's back again. From bash when I run cat sample.txt | ./app I get app.fsx(39,43): error FS0039: The value or constructor 'parseArgs' is not defined.
(think think code checkin)
// That looks real nice, Grok. Let's do a bit more cleanup in anticipation of making this into a templaed project folder for Visual Studio. First, right now we're using tabs for delimiters. I'd like to be able to default to tabs, but add a --delim command line option to take any regex string and use it. We're also using that sample.txt file, let's rename that to appsample.txt in order to keep with the idea that app will be a generic name and we'll replace it all later with the actual name of the project once its instantiated. Be sure to update the help along with providing a usage example. 
(think think think code checkin)
// there was a lookup fix I forgot to log
// I like the way you did the smoke tests in app-test.fsx That's exactly what I wanted. Now, it'd be nice if it was also possible to test in this function as a human sitting at the command line. Since our two scripts are wrapped, because I only wanted to use one word, this would simply involve running something depending on the OS type from the command to see if it fails or not. For instance, in bash, I'd run cat appsample.txt | ./app while in DOS I'd run type appsample.txt | app Can you add in a seventh smoke test here that would run either of these commands depending on the OS just to see if it fails or not? If so, I have a few more I'd like to add
(think think think code checkin)
// Well that didn't seem to work, grok.  When I try to use either of these scripts, app.fsx or app-test.fsx in doesn't compile. For example from bash when I type in  cat appsample.txt | ./app I get app.fsx(32,13): error FS0001: All branches of an 'if' expression must return values implicitly convertible to the type of the first branch, which here is 'unit'. This branch returns a value of type 'bool'.  
(think think think code checkin)
// note: two things. First, the IDE itself sometimes "helps" me with various forms of auto completion. If I'm pasting in grok code, this means that at times simply hitting return auto adds things -- or at least makes it more confusing. Second, grok meters out the replies it gives which means that I need to double check to make sure it's done before copying and pasting. Finally, I can't simply replace parts of code. I'll ask it to fix one thing and it'll rewrite or screw up something somewhere else
