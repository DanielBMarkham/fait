Hey, I'd like you to generate some code for me. I outlined what I'd like.

### Structure
I would like five files in total.
- A text file full of common English nouns, verbs, adverbs, and ajectives. These words should be randomly generated and put into clusters separated by tabs. There should be a 100 lines of this text file. I will call this sample.txt. Each line may contain no clusters in columns or it may contain up to a dozen such clusters. Each cluster can be up to seven randomly chosen words. Empty columns can appear can appear in any location
- The next two files will be companion files and architected and coded as much of the same way as possible. They will be F# script files runnable from either bash or dos. They will be named app.fsx and app-test.fsx
- The final two files will be OS commands that wrap these files for each of the OSes. These will have the same name as their corresponding F# script files. For instance, there will be an app.cmd that calls the app.fsx from the dos command line. Likewise there should be an app file with bash shell instructions to call the bash version of these. The goal is to just use one simple word for running these apps from the command line. This should help future programmers use the code without having to know all of the details underneath.
- These files will contain no linkages or dependencies on anything but the underlying dotnet sdk code or OS framework. There are no custom libraries, database drivers, or helper files. As much as possible, there should never be an issue with some vendor code being patched or updated and it breaking these two F# script files. Because of the way we're wrapping these two scripts, the same text should result in the same result regardless of which OS the user is using.
- As much as possible, all F# code should be written as pure functions
- Since both the app and test use a jagged string array with holes, at the heart of both the app script and the app-test script should be a function. It takes a string array, does something with it, I don't care, reverses everything maybe, and returns the same type. This means that in addition to app and app-test being mirror programs, each able to recieve the output of the other, these two functions are same. This means that future users of the code can use the functionality by simply bypassing all the IO and calling these functions directly
- The test app will not necessarily use its input data as tests, at least not now. Instead, you'll add six "smoke tests" that will be used later to verify basic operation. You can code in whatever you'd like here. Maybe a bit of passing and failing. When the test gets a result, it puts it in a WARN log message, in addition to logging entrance and exit if the INFO option has been selected

### Operation
In operation, these two script files should perform just like the cat utility built into bash, except they use the data instead of just typing it out like cat does. This means several things
- Because they work like cat, the programs should error error out. They always do something, even if it's just waiting on input. They provide the user with unexpected results, but there never should be a programming problem that tosses an exception back at the user. It just works.
- Since they both generate and consume tab delimited text, each one should be able to pipe into the other one. In other words, in bash cat sample.txt | app | app-test should work without error as well as the reverse, cat sample.txt | app-test | app
- These programs should operate in stream mode, not loading everything in at once. This will allow other programs to open a pipe to these apps and write intermittantly over time without have to restart the app. When they close the stream, then the program closes
- If a file is provided by stream, such as the example above, app and app-test processes that stream and then releases all resources
- All input and output to these scripts should use the OS standard, eg stdin, stout, and sterr
- Each of these two scripts should support a default set of command line parameters that one would expect from the underlying OS. -i for input file, -o for output file, -v to set verbosity level, and -h for help
- If the help option is provided, the appropriate help information is sent out first, before any processing takes place. This allows new users to make mistakes and then correct them, such as having a hanging terming (where neither an input file or piped input is provided, they're left to provide text by typing it in at the console, which isn't always clear to them.) The help text should explain all of the options and provide several usage examples in both dos and bash.
- verbosity has three levels, INFO, WARN, and ERROR. ERROR is the default. When requesting the INFO mode, all function entrances and exits are logged

### Testing
In adition to all of this, if you can provide any of this also as an executable test called from the command line, that would be great. Should be one version for bash and one for dos

// You made a try-with-finally when you can't do that. It has to be a try-finally wrapping another try-with. Here, I fixed it for you 
(think code checkin)
// I need you to make the command line options double dash instead of single dash, ie --h instead of -h. Otherwise the options keep escaping the script and end up being processed by dotnet. Be sure to fix both files
(think think code checkin)
// Smoke tests run. Can you add in a --dt option that puts a high precision UTC datetime at the beginning of any log message?
(think think think code checkin)
