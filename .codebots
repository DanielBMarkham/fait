I've got a new greenfield programming project for you, Grok. I want you to think very carefully about the code you provide as there are a lot of details you shouldn't forget

### Goal 
The goal of this code will be to create two console applications that both have the same inputs and outputs from the command line. We will use a jagged sparse string array as sample data since this echos the types of data a user might stream in or out of a CLI application. These will be F# scripts and will be named app2.fsx and app2-test.fsx. Since we are trying to make the architectures of the two as similar as possible, there will be a common F# script file that will be used by both. It will be named app32lib.fsx It is expected that these two scripts will operate for the user as similar to the built in linux commands as possible. In other words, the programs might produce the wrong data or wait on the user to manually enter the string data, but they should never ever fail out by throwing exceptions to the OS. app3lib.fsx, the shared scripot, will be written in only purely functional code. Each of the main scripts, app2.fsx and app2-test.fsx, will be written using as much functional code as possible. This is so that app2lib can be used from other script files without having to worry about any external dependencies. They should run in both DOS and linux, but the idea is that they will run anywhere the dotnet sdk can be installed.

### Testing
For ease of use and conversation, both app2.fsx and app2-test.fsx should be wrapped by a batch file in DOS and bash. app2 for bash and app2.cmd for DOS. From here on out we'll simply refer to them as app2 and app2-test although we'll be testing on both DOS and linux. I have created a hundred line sparse string array to use for testing. It's called appsample.txt. Since the inputs and outputs of both of these programs are the same, the output of one should be able to pipe into the input of the other, for as many pipes and combinations as possible, ie cat appsample.txt | app2 | app2-test | app2-test | app2 -- for as long as we want to add pipes should work. This also means that they should work in streaming mode instead of loading up the entire file at once, although each file should also have an option to use an external filename for input or output instead of streaming data in from the OS or having the user manually enter data (which should also work) Although the external architecture and interaction to both scripts should be the same, internally over in app2lib.fsx each should have its own set of pure functions supporting it. So, for instance, there should be a processAppTestData alongside a processAppData function. This is the only place using common code is not desired as eventually each of the two scripts will be used for different purposes.

### Conversation and iteration
Initially let's just reverse the order of columns in each line. That way when we run two piped to one another we should get the initial input file. This also gives me a place to drop the actual code in later once we finish our conversation. I will be black boxing both app2 and app2-test from the dos and linux command line as much as possible, although I will also be looking at your code when tests fail in order to provide more useful feedback. Internally there should be an array of two types of tests that we will be using. This array is the smoke tests for both apps. One type of test in on the incoming data itself. Can it handle an empty line, can it handle the user skipping columns. What if the user uses 15 columns, or 6, or 1? What about empty data streaming in? If a filename has been selected and there's nothing coming in, that should produce nothing. Without a filename, however, we should wait on the user to use the console to type things in. All of these kinds of tests should use the pure functions over in app2lib. This brings us to the second type of smoke test, the external OS test. We will type in various console commands from either dos or bash. You will, based on the OS, reproduce those tests to see if you get similar behavior. As we find and solve various problems, you will add to the test array so that we will not encounter those problems again.


### Structure
There should be no dependencies on anything but the dotnet sdk and the underlying OS. This means we should be able to lift and move these scripts anywhere that dotnet runs and they'll run fine. We will be using both OS pipes and command line options to exercise the code. Command line options should be written using the double-dash, ie --h for help, not -h. Intially we will support these options from the command line both for app2 and app2-test
--h Help, name the app, provide the usual help, be sure to provide some usage scenarios. If the help option is used, help should be written out first before any other processing takes place. Provide usage scenarios for both DOS and BASH
--v Verbosity There'll be three levels, INFO, WARN, and ERROR. If a user picks the INFO level, log the entrance and exit of every function. WARN will be the default This level will indicate that something odd has happened but we're continuing on anyway. ERROR means that we have crashed back out to the main script entrance point. At that point it'll be caught, logged, and the program will exit safely
-- i and --o or --input and --output Provides the file to read instead of using streaming. 
-- d or --delim specify a regex to use as a column delimiter instead of the default tab character
-- t or --tests Don't operate normally. Instead run this array of the two types of smoke tests we've been talking about. Be sure that as we find failures and modify the program we also update this list so that it doesn't happen again
-- dt or --datetime add in a high precision datetime to the beginning of any log message


### Considerations
These two scripts are expected to be used as a dotnet project template for future programmers to use. They will provide the innards and actual functionality of app2 and app2-test instead of the defaul column reversal functionality. They should be able to use them either stand-alone or by simply referencing the shared library in their code. This means that this should be able to deploy as a script, app, monolith, microservice, and so on. As a future project template, we should never be tied to any one deployment pattern. Anyone familiar with using either F# or the cat or type utility in bash or dos should be able to use this code without any additional training or help

(think think think code)

// Gosh grok, when I type in my first test it doesn't work. I type in cat appsample.txt | ./app2 and I get app2.fsx(123,47): error FS3373: Invalid interpolated string. Single quote or verbatim string literals may not be used in interpolated expressions in single quote or verbatim strings. Consider using an explicit 'let' binding for the interpolation expression or use a triple quote string as the outer string literal.

// Now when I type in cat appsample.txt | ./app2 I get app2.fsx(188,5): error FS0010: Unexpected keyword 'finally' in binding. Expected incomplete structured construct at or before this point or other token. F# does not support using both with and finally. You'll need something nested. How about putting a try-finally outside and then put a try-with on the inside

(think think think code)
// Now when I type in cat appsample.txt | ./app2 I get app2.fsx(161,13): error FS0001: All branches of a pattern match expression must return values implicitly convertible to the type of the first branch, which here is 'TextWriter'. This branch returns a value of type 'StreamWriter'.

(think think think code)
// Now when I type in cat appsample.txt | ./app2 I get app2.fsx(167,19): error FS0003: This value is not a function and cannot be applied. Also you don't need to upcast on line 161 that gets a warning. (also looks a lot like hacking)